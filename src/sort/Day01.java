package sort;

import java.util.Arrays;

/**
 * @description  描述:冒泡排序
 *
 * 基本概念：
 * 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
 * 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。
 * 在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，
 * 一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。
 * 如此下去，重复以上过程，直至最终完成排序。
 *
 * 实现思路：
 * 用二重循环实现，外循环变量设为i，内循环变量设为j。假如有n个数需要进行排序，则外循环重复n-1次，
 * 内循环依次重复n-1，n-2，...，1次。每次进行比较的两个元素都是与内循环j有关的，
 * 它们可以分别用a[j]和a[j+1]标识，i的值依次为1,2,...,n-1，对于每一个i，j的值依次为0,1,2,...n-i 。
 *
 * 设数组长度为N：
 * 1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。
 * 2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。
 * 3．N=N-1，如果N不为0就重复前面二步，否则排序完成。
 *
 * @author  LT
 * @date  2020/7/20
 */
public class Day01 {

    /**
     * 冒泡排序
     * 若记录序列的初始状态为"正序"，则冒泡排序过程只需进行一趟排序，在排序过程中只需进行n-1次比较，且不移动记录；反之，若记录序列的初始状态为"逆序"，则需进行n(n-1）/2次比较和记录移动。因此冒泡排序总的时间复杂度为O(n*n)。
     * @param arr
     */
    public static void bubleSort(int[] arr) {
        // 定义一个临时变量
        int temp;
        for (int i = 0; i < arr.length -1; i++) {
            for (int j = 0; j < arr.length - i - 1; j++) {
                if (arr[j+1] < arr[j]) {
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[] {1,6,22,5,1};
        Day01.bubleSort(arr);
        System.out.println(Arrays.toString(arr));
    }

}
